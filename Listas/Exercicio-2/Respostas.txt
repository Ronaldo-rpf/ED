Parte I:

3 - Essa linha chama a função initLstE(), que retorna um ponteiro do tipo tpNO, ponteiro esse que aponta para o início da lista encadeada, mas como ainda não existem nós nessa lista, ele começa apontando para NULL, e atribui esse retorno ao ponteiro lstAlunos, que também é do tipo tpNO, ou seja, lstAlunos é o ponteiro que aponta para o início da lista encadeada.

4 - Essa linha apresenta uma função, essa função cadastra um novo nó na lista encadeada, incluindo o nome do aluno e sua matrícula. Ademais, o parâmetro é um ponteiro duplo, pois assim, ele altera diretamente o ponteiro inicial da lista, fazendo o mesmo apontar para a nova célula cadastrada, que será o novo primeiro nó. Ou seja, como o ponteiro que aponta para o inicio da lista é um ponteiro propriamente dito, precisamos criar um ponteiro duplo para acessá-lo por referência (endereço de memória) e assim, modificá-lo de fato.

5 - 
A função "insertLstE" pertence a classe assintótica das funções constantes, tanto no pior quanto no melhor caso. O melhor caso, O (o grande), é quando a função não entra no if, quando o malloc comete algum erro e retorna NULL para o ponteiro "no", pois o número total de comparações e atribuições é de 3, independete de qualquer outra variável, ou seja, é constante. O pior caso, ômega (Ω), é quando a função executa o if, pois no total temos 6 execuções (comparações e atribuições).

A função "printLstE" baseia sua eficiência de tempo na quantidade de itens que a lista encadeada possui. O melhor caso, O (o grande), é quando a lista não possui nenhum nó, ou seja, o ponteiro "lst" aponta para NULL, indicando que não há nenhuma célula na lista, não executando o while e fazendo somente 1 execução (comparações e atribuições) na própria verificação da estrutura de repetição, uma função constante. O pior caso, ômega (Ω), é diretamente proporcional ao número de nós cadastrados na lista encadeada, pois até que o ponteiro "lst" aponte para NULL, o while continuará sendo executado, e fazendo mais e mais execuções, obedecendo a função n, uma função linear. Com isso, pode-se dizer que a função "printLstE" não possui uma classe assintótica definida, pois o seu melhor e pior caso pertencem a classes diferentes, uma é constante e a outra linear.

A função "searchItemLstE" também não possui uma classe assintótica definida, pois o seu melhor e pior caso pertencem a classes diferentes, uma é constante e a outra linear, e baseia sua eficiência de tempo na quantidade de itens que a lista encadeada possui. O melhor caso, O (o grande), é quando o ponteiro "lst" aponta para NULL, ou seja, não há nenhum nó na lista encadeada, fazendo somente 2 execuções (comparações e atribuições), uma função constante. O pior caso, ômega (Ω), é diretamente proporcional ao número de nós cadastrados na lista encadeada, e obedece a função 3n + 2, uma função linear.



Parte II:
O problema no cadastro de alunos é o scanf para pegar o nome do aluno, pois quando digitamos mais de um nome, ou seja, o nome completo do aluno, por exemplo, ele guarda no buffer do teclado o espaço entre o primeiro e o segundo nome, e por padrão, ele tenta colocar o que está no buffer na próxima entrada de escrita, ou seja, a matrícula do aluno, que acaba ficando vazia ou com algum "lixo" da memória (números sem uso), ocasionando no erro, e quando tentamos cadastrar novamente outro aluno na sequência, ele coloca o segundo nome do aluno cadastrado anteriormente, pois este está no buffer do teclado ainda, ocasionando uma cadeia de erros. Para concertar usarei o fgets, que considera normalmente os espaços e evita esses tipos de erro, normalizando o buffer do teclado, e o mesmo ocorre para pegar a matrícula do aluno, mas podemos usar a função getchar() ou fflush(stdin) para limpar o '\n' final do número e continuar normalmente sem um buffer. 
